<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// setup
name = obj_menu.name;

// past positions
pastx = ds_list_create();
pasty = ds_list_create();
lastx = 0;
lasty = 0;
snaps = 0;
snapl = 30;

// keys
keys_old = 0;
keys_new = 0;

// connection
connected = false;
ip = obj_menu.ip;
port = obj_menu.port;
last_ip = "";
last_port = 0;
pingold = 0;
ping = 0;

client = network_create_server(network_socket_udp,0,1);

// data
pack_in = 0;
pack_out = 0;
data_in = 0;
data_out = 0;
data_in_sec = 0;
data_out_sec = 0;
last_ack = 0;

buff_queue = ds_priority_create();
data_max_total1 = 1 * 1024;
data_max_total2 = data_max_total1 / 12;

data_timer1 = 60;
data_total1 = 0;
data_timer2 = 5;
data_total2 = 0;

// client info
clients = 0;
client_map = ds_map_create();
client_id = -1;

// entity info
entities = 0;
entity_map = ds_map_create();
entity_updates = 0;

var send_buff = client_queue_buffer(4,1);
buffer_write(send_buff,buffer_u8,0);
buffer_write(send_buff,buffer_s8,0);

physics_world_create(1/16);
physics_world_gravity(0,50);
physics_world_update_speed(60);
physics_world_update_iterations(8);

view = 0;
vx = 0;
vy = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[0] = room_speed * 3;
pingold = get_timer();
                
// reply accordingly
buff = client_queue_buffer(8,1);
buffer_write(buff,buffer_u8,client_id);
buffer_write(buff,buffer_s8,127);
buffer_write(buff,buffer_u8,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>data_timer1--;
if (data_timer1 &lt;= 0)
    {
    data_total1 = 0;
    data_timer1 = 60;
    }
data_timer2--;
if (data_timer2 &lt;= 0)
    {
    data_total2 = 0;
    data_timer2 = 5;
    }

var send = !(ds_priority_empty(buff_queue));
while(send)
    {
    // grab next packets details
    var buff = ds_priority_find_max(buff_queue);
    var priority = ds_priority_find_priority(buff_queue,buff);
    
    // check if we arent overloading the client
    if (priority == 1) or ((priority &gt; data_total1 / data_max_total1) and (priority &gt; data_total2 / data_max_total2))
        {
        // send the packet and update the clients total data throughput
        network_send_udp(client,ip,port,buff,buffer_tell(buff));
        
        var size = buffer_tell(buff);
        data_total1 += size;
        data_total2 += size;
        data_out_sec += size;
        data_out += size;
        pack_out++;
        
        // remove buffer from queue and delete buffer
        ds_priority_delete_value(buff_queue,buff);
        buffer_delete(buff);
        }
    else send = false;
    
    // no more messages in queue
    if (ds_priority_empty(buff_queue))
        send = false;
    }

// quit and send keys to server
if (keyboard_check_pressed(vk_escape))
    {
    var buff = client_queue_buffer(8,1);
    buffer_write(buff,buffer_u8,client_id);
    buffer_write(buff,buffer_s8,1);
    // game_end();
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>vx = 0;
vy = 0;

view_xview[0] += (vx-view_xview[0])*0.2;
view_yview[0] += (vy-view_yview[0])*0.2;
view_xview[0] = floor(view_xview[0]);
view_yview[0] = floor(view_yview[0]);

keys_old = keys_new;
keys_new = 0;

if (keyboard_check(ord("W")))
    keys_new = (keys_new | 1);
if (keyboard_check(ord("A")))
    keys_new = (keys_new | 2);
if (keyboard_check(ord("S")))
    keys_new = (keys_new | 4);
if (keyboard_check(ord("D")))
    keys_new = (keys_new | 8);

if (mouse_check_button_pressed(mb_left))
    {
    var xx = floor(mouse_x/16);
    var yy = floor(mouse_y/16);
    
    var buff = client_queue_buffer(8,0.9);
    buffer_write(buff,buffer_u8,client_id);
    buffer_write(buff,buffer_u8,3);
    buffer_write(buff,buffer_u8,0);
    buffer_write(buff,buffer_s16,xx);
    buffer_write(buff,buffer_s16,yy);
    }

if (mouse_check_button_pressed(mb_right))
    {
    var xx = floor(mouse_x/16);
    var yy = floor(mouse_y/16);
    
    var buff = client_queue_buffer(8,0.9);
    buffer_write(buff,buffer_u8,client_id);
    buffer_write(buff,buffer_u8,3);
    buffer_write(buff,buffer_u8,1);
    buffer_write(buff,buffer_s16,xx);
    buffer_write(buff,buffer_s16,yy);
    }

if !(instance_exists(obj_player))
    exit;

if (mouse_x &gt;= obj_player.x)
    keys_new = (keys_new | 16);

// send keys to server
if (keys_new != keys_old)
    {
    var buff = client_queue_buffer(8,0.9);
    buffer_write(buff,buffer_u8,client_id);
    buffer_write(buff,buffer_s8,2);
    buffer_write(buff,buffer_u8,keys_new);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_map_find_value(async_load,"id") != client)
    exit;

if (ds_map_find_value(async_load,"type") == network_type_data) // dealing with UDP data
    {
    net_ip = ds_map_find_value(async_load,"ip"); // last ip
    net_port = ds_map_find_value(async_load,"port"); // last port
    net_buff = ds_map_find_value(async_load,"buffer"); // buffer ID of payload data
    net_size = ds_map_find_value(async_load,"size"); // size of buffer in bytes
    
    var usr_id = buffer_read(net_buff,buffer_u8);
    var msg_id = buffer_read(net_buff,buffer_s8);
    //var ack_id = buffer_read(net_buff,buffer_u8);
    
    // handle payload
    if (usr_id == 255)
        {
        data_in_sec += net_size;
        data_in += net_size;
        pack_in++;
        
        switch(msg_id)
            {
            case 0: // connection successful, grab client id
                connected = true;
                client_id = buffer_read(net_buff,buffer_u8);
                alarm[0] = room_speed * 3;
                
                buff = client_queue_buffer(64,1);
                buffer_write(buff,buffer_u8,client_id);
                buffer_write(buff,buffer_s8,0);
                buffer_write(buff,buffer_string,name);
                break;
            
            case 1: // receive previously connected players
                clients = buffer_read(net_buff,buffer_u8);
                for(var i=0; i&lt;clients; i++;)
                    {
                    var net_id = buffer_read(net_buff,buffer_u8);
                    var net_name = buffer_read(net_buff,buffer_string);
                    
                    if (net_id == client_id)
                        var inst = instance_create(0,0,obj_player);
                    else
                        var inst = instance_create(16,16,obj_otherplayer);
                    
                    inst.usr_id = net_id;
                    inst.name = net_name;
                    
                    ds_map_add(client_map,inst.usr_id,inst);
                    }
                
                entities = buffer_read(net_buff,buffer_u16);
                for(var i=0; i&lt;entities; i++;)
                    {
                    var n_id = buffer_read(net_buff,buffer_u16);
                    var type = buffer_read(net_buff,buffer_u8);
                    var xx = buffer_read(net_buff,buffer_f32);
                    var yy = buffer_read(net_buff,buffer_f32);
                    
                    var temp_fix = physics_fixture_create();
                    var inst = instance_create(xx,yy,obj_ball);
                    if (type == 0)
                        {
                        physics_fixture_set_box_shape(temp_fix,16,16);
                        physics_fixture_set_density(temp_fix,0);
                        inst.sprite_index = spr_wall;
                        }
                    else
                        {
                        physics_fixture_set_circle_shape(temp_fix,16);
                        physics_fixture_set_density(temp_fix,0.5);
                        inst.sprite_index = spr_ball;
                        inst.static = false;
                        }
                    physics_fixture_bind(temp_fix,inst);
                    physics_fixture_delete(temp_fix);
                    
                    ds_map_add(entity_map,n_id,inst);
                    }
                break;
            
            case 2: // someone connects/disconnects
                if (buffer_read(net_buff,buffer_u8))
                    {
                    var inst = instance_create(16,16,obj_otherplayer);
                    inst.usr_id = buffer_read(net_buff,buffer_u8);
                    inst.name = buffer_read(net_buff,buffer_string);
                        
                    ds_map_add(client_map,inst.usr_id,inst);
                    clients++;
                    }
                else
                    {
                    var net_id = buffer_read(net_buff,buffer_u8);
                    var inst = ds_map_find_value(client_map,net_id);
                    if (inst != undefined)
                        {
                        ds_map_delete(client_map,net_id);
                        with(inst)
                            instance_destroy();
                        
                        clients--;
                        }
                    }
                break;
            
            case 4: // player keys
                var net_id = buffer_read(net_buff,buffer_u8);
                var keys_net = buffer_read(net_buff,buffer_u8);
                
                var inst = ds_map_find_value(client_map,net_id);
                if (inst != undefined)
                    {
                    inst.key_north = (keys_net &amp; 1 == 1);
                    inst.key_west = (keys_net &amp; 2 == 2);
                    inst.key_south = (keys_net &amp; 4 == 4);
                    inst.key_east = (keys_net &amp; 8 == 8);
                    inst.key_face = (keys_net &amp; 16 == 16);
                    }
                break;
            
            case 5: // player pos
                var client_udpates = buffer_read(net_buff,buffer_u8);
                var entity_updates = buffer_read(net_buff,buffer_u16);
                var client_details = buffer_read(net_buff,buffer_u8);
                
                // always update players positions
                for(var i=0; i&lt;client_udpates; i++;)
                    {
                    var net_id = buffer_read(net_buff,buffer_u8);
                    var xpos = buffer_read(net_buff,buffer_f32);
                    var ypos = buffer_read(net_buff,buffer_f32);
                    
                    if (client_details)
                        {
                        var xspd = buffer_read(net_buff,buffer_s16) / 1000;
                        var yspd = buffer_read(net_buff,buffer_s16) / 1000;
                        var xvel = buffer_read(net_buff,buffer_s16) / 1000;
                        var yvel = buffer_read(net_buff,buffer_s16) / 1000;
                        var rot8 = buffer_read(net_buff,buffer_s16) / 10;
                        var rspd = buffer_read(net_buff,buffer_s16) / 10;
                        
                        var inst = ds_map_find_value(client_map,net_id);
                        if (inst != undefined)
                            {
                            if (sqr(inst.phy_position_x - xpos) + sqr(inst.phy_position_y - ypos) &gt; 144)
                                {
                                if (global.debug)
                                    {
                                    (instance_create(xpos,xpos,obj_marker)).col = c_blue;
                                    (instance_create(inst.x,inst.y,obj_marker)).col = c_red;
                                    }
                                
                                inst.phy_position_x = xpos;
                                inst.phy_position_y = ypos;
                                inst.phy_speed_x = xspd;
                                inst.phy_speed_y = yspd;
                                inst.phy_linear_velocity_x = xvel;
                                inst.phy_linear_velocity_y = yvel;
                                inst.phy_rotation = rot8;
                                inst.phy_angular_velocity = rspd;
                                }
                            }
                        }
                    else
                        {
                        var inst = ds_map_find_value(client_map,net_id);
                        if (inst != undefined)
                            {
                            if (sqr(inst.phy_position_x - xpos) + sqr(inst.phy_position_y - ypos) &gt; 144)
                                {
                                if (global.debug)
                                    {
                                    (instance_create(xpos,xpos,obj_marker)).col = c_blue;
                                    (instance_create(inst.x,inst.y,obj_marker)).col = c_red;
                                    }
                                
                                inst.phy_position_x = xpos;
                                inst.phy_position_y = ypos;
                                }
                            }
                        }
                    }
                
                // entity positions
                for(var i=0; i&lt;entity_updates; i++;)
                    {
                    var n_id = buffer_read(net_buff,buffer_u16);
                    var phys_inst = ds_map_find_value(entity_map,n_id);
                    if (phys_inst == undefined)
                        {
                        buffer_seek(net_buff,buffer_seek_relative,20);
                        }
                    else
                        {
                        var xpos = buffer_read(net_buff,buffer_f32);
                        var ypos = buffer_read(net_buff,buffer_f32);
                        var xspd = buffer_read(net_buff,buffer_s16) / 1000;
                        var yspd = buffer_read(net_buff,buffer_s16) / 1000;
                        var xvel = buffer_read(net_buff,buffer_s16) / 1000;
                        var yvel = buffer_read(net_buff,buffer_s16) / 1000;
                        var rot8 = buffer_read(net_buff,buffer_s16) / 10;
                        var rspd = buffer_read(net_buff,buffer_s16) / 10;
                        
                        if (sqr(phys_inst.phy_position_x - xpos) + sqr(phys_inst.phy_position_y - ypos) &gt; 144)
                            {
                            phys_inst.phy_position_x = xpos;
                            phys_inst.phy_position_y = ypos;
                            phys_inst.phy_speed_x = xspd;
                            phys_inst.phy_speed_y = yspd;
                            phys_inst.phy_linear_velocity_x = xvel;
                            phys_inst.phy_linear_velocity_y = yvel;
                            phys_inst.phy_rotation = rot8;
                            phys_inst.phy_angular_velocity = rspd;
                            }
                        }
                    }
                break;
            
            case 6: // new physics object
                var n_id = buffer_read(net_buff,buffer_u16);
                var type = buffer_read(net_buff,buffer_u8);
                var xx = buffer_read(net_buff,buffer_s16);
                var yy = buffer_read(net_buff,buffer_s16);
                
                var temp_fix = physics_fixture_create();
                var inst = instance_create(xx*16,yy*16,obj_ball);
                if (type == 0)
                    {
                    physics_fixture_set_box_shape(temp_fix,16,16);
                    physics_fixture_set_density(temp_fix,0);
                    inst.sprite_index = spr_wall;
                    }
                else
                    {
                    physics_fixture_set_circle_shape(temp_fix,16);
                    physics_fixture_set_density(temp_fix,0.5);
                    inst.sprite_index = spr_ball;
                    inst.static = false;
                    }
                physics_fixture_bind(temp_fix,inst);
                physics_fixture_delete(temp_fix);
                
                entities++;
                ds_map_add(entity_map,n_id,inst);
                break;
            
            case 127: // ping
                ping = (get_timer()-pingold)/1000;
                
                // reply accordingly
                var buff = client_queue_buffer(8,1);
                buffer_write(buff,buffer_u8,client_id);
                buffer_write(buff,buffer_s8,127);
                buffer_write(buff,buffer_u8,1);
                break;
            }
        }
    
    //last_ack = ack_id;
    }


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_halign(2);
draw_set_color(c_white);
draw_text(view_wview[0]-12,12,"fps: "+string(fps_real)+"#data: "+string(data_in)+"B / "+string(data_out)+"B#packets: "+string(pack_in)+" / "+string(pack_out)+"#ping: "+string(ping)+"ms#entity updates: "+string(entity_updates)+" / "+string(entities));
draw_set_halign(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
